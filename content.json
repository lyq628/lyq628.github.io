{"meta":{"title":"好好学习 天天向上","subtitle":"","description":null,"author":"高天","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Postgresql创建各种进程","slug":"Postgresql创建进程","date":"2021-02-05T16:34:52.000Z","updated":"2021-02-06T08:21:26.713Z","comments":true,"path":"2021/02/06/Postgresql创建进程/","link":"","permalink":"http://yoursite.com/2021/02/06/Postgresql%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"[TOC] 问题 PG的进程是在何时、何处创建的？ 各创建什么进程？ 每个进程的用途是什么？ PG进程结构 进程 概述 baskground writer 负责将共享缓冲池中的脏页逐渐刷入持久化存储中 checkpointer 处理检查点 autovacuum launcher 周期性启动自动清理工作进程 Wal writer 周期性将WAL缓冲区中的wal数据刷入持久存储中 statistics collector 负责收集统计信息，用于pg_stat_activity/pg_stat_database logging collector(logger) 负责将错误消息写入日志文件 archiver 负责将日志归档 PG进程创建 main.c -&gt; postmaster.c#PostmasterMain中共计3处进行各种进程创建 1SysLoggerPID = SysLogger_Start(); 1StartupPID = StartupDataBase(); 1status = ServerLoop(); 1）创建logger进程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189/* * Postmaster subroutine to start a syslogger subprocess. */intSysLogger_Start(void)&#123; pid_t sysloggerPid; char *filename; if (!Logging_collector) return 0; /* * If first time through, create the pipe which will receive stderr * output. * * If the syslogger crashes and needs to be restarted, we continue to use * the same pipe (indeed must do so, since extant backends will be writing * into that pipe). * * This means the postmaster must continue to hold the read end of the * pipe open, so we can pass it down to the reincarnated syslogger. This * is a bit klugy but we have little choice. */#ifndef WIN32 if (syslogPipe[0] &lt; 0) &#123; if (pipe(syslogPipe) &lt; 0) ereport(FATAL, (errcode_for_socket_access(), (errmsg(\"could not create pipe for syslog: %m\")))); &#125;#else if (!syslogPipe[0]) &#123; SECURITY_ATTRIBUTES sa; memset(&amp;sa, 0, sizeof(SECURITY_ATTRIBUTES)); sa.nLength = sizeof(SECURITY_ATTRIBUTES); sa.bInheritHandle = TRUE; if (!CreatePipe(&amp;syslogPipe[0], &amp;syslogPipe[1], &amp;sa, 32768)) ereport(FATAL, (errcode_for_file_access(), (errmsg(\"could not create pipe for syslog: %m\")))); &#125;#endif /* * Create log directory if not present; ignore errors */ (void) MakePGDirectory(Log_directory); /* * The initial logfile is created right in the postmaster, to verify that * the Log_directory is writable. We save the reference time so that the * syslogger child process can recompute this file name. * * It might look a bit strange to re-do this during a syslogger restart, * but we must do so since the postmaster closed syslogFile after the * previous fork (and remembering that old file wouldn't be right anyway). * Note we always append here, we won't overwrite any existing file. This * is consistent with the normal rules, because by definition this is not * a time-based rotation. */ first_syslogger_file_time = time(NULL); filename = logfile_getname(first_syslogger_file_time, NULL); syslogFile = logfile_open(filename, \"a\", false); pfree(filename); /* * Likewise for the initial CSV log file, if that's enabled. (Note that * we open syslogFile even when only CSV output is nominally enabled, * since some code paths will write to syslogFile anyway.) */ if (Log_destination &amp; LOG_DESTINATION_CSVLOG) &#123; filename = logfile_getname(first_syslogger_file_time, \".csv\"); csvlogFile = logfile_open(filename, \"a\", false); pfree(filename); &#125;#ifdef EXEC_BACKEND switch ((sysloggerPid = syslogger_forkexec()))#else switch ((sysloggerPid = fork_process()))#endif &#123; case -1: ereport(LOG, (errmsg(\"could not fork system logger: %m\"))); return 0;#ifndef EXEC_BACKEND case 0: //子进程返回 /* in postmaster child ... */ InitPostmasterChild(); /* Close the postmaster's sockets */ ClosePostmasterPorts(true); /* Drop our connection to postmaster's shared memory, as well */ dsm_detach_all(); PGSharedMemoryDetach(); /* do the work */ SysLoggerMain(0, NULL); break;#endif default: //父进程烦返回 /* success, in postmaster */ /* now we redirect stderr, if not done already */ if (!redirection_done) &#123;#ifdef WIN32 int fd;#endif /* * Leave a breadcrumb trail when redirecting, in case the user * forgets that redirection is active and looks only at the * original stderr target file. */ ereport(LOG, (errmsg(\"redirecting log output to logging collector process\"), errhint(\"Future log output will appear in directory \\\"%s\\\".\", Log_directory)));#ifndef WIN32 fflush(stdout); if (dup2(syslogPipe[1], fileno(stdout)) &lt; 0) ereport(FATAL, (errcode_for_file_access(), errmsg(\"could not redirect stdout: %m\"))); fflush(stderr); if (dup2(syslogPipe[1], fileno(stderr)) &lt; 0) ereport(FATAL, (errcode_for_file_access(), errmsg(\"could not redirect stderr: %m\"))); /* Now we are done with the write end of the pipe. */ close(syslogPipe[1]); syslogPipe[1] = -1;#else /* * open the pipe in binary mode and make sure stderr is binary * after it's been dup'ed into, to avoid disturbing the pipe * chunking protocol. */ fflush(stderr); fd = _open_osfhandle((intptr_t) syslogPipe[1], _O_APPEND | _O_BINARY); if (dup2(fd, _fileno(stderr)) &lt; 0) ereport(FATAL, (errcode_for_file_access(), errmsg(\"could not redirect stderr: %m\"))); close(fd); _setmode(_fileno(stderr), _O_BINARY); /* * Now we are done with the write end of the pipe. * CloseHandle() must not be called because the preceding * close() closes the underlying handle. */ syslogPipe[1] = 0;#endif redirection_done = true; &#125; /* postmaster will never write the file(s); close 'em */ fclose(syslogFile); syslogFile = NULL; if (csvlogFile != NULL) &#123; fclose(csvlogFile); csvlogFile = NULL; &#125; return (int) sysloggerPid; &#125; /* we should never reach here */ return 0;&#125; 核心流程为PostMaster创建Pipe，创建子进程SysLogger之后，PostMaster关闭pipe[1]（读端），SysLogger关闭写端(pipe[0])。 2）创建StartupDataBase进程12345678910111213141516171819202122232425#define StartupDataBase() StartChildProcess(StartupProcess)#define StartBackgroundWriter() StartChildProcess(BgWriterProcess)#define StartCheckpointer() StartChildProcess(CheckpointerProcess)#define StartWalWriter() StartChildProcess(WalWriterProcess)#define StartWalReceiver() StartChildProcess(WalReceiverProcess)/* * Auxiliary-process type identifiers. These used to be in bootstrap.h * but it seems saner to have them here, with the ProcessingMode stuff. * The MyAuxProcType global is defined and set in bootstrap.c. */typedef enum&#123; NotAnAuxProcess = -1, CheckerProcess = 0, BootstrapProcess, StartupProcess, BgWriterProcess, CheckpointerProcess, WalWriterProcess, WalReceiverProcess, NUM_AUXPROCTYPES /* Must be last! */&#125; AuxProcType; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/* * StartChildProcess -- start an auxiliary process for the postmaster * * \"type\" determines what kind of child will be started. All child types * initially go to AuxiliaryProcessMain, which will handle common setup. * * Return value of StartChildProcess is subprocess' PID, or 0 if failed * to start subprocess. */static pid_tStartChildProcess(AuxProcType type)&#123; pid_t pid; char *av[10]; int ac = 0; char typebuf[32]; /* * Set up command-line arguments for subprocess */ av[ac++] = \"postgres\";#ifdef EXEC_BACKEND av[ac++] = \"--forkboot\"; av[ac++] = NULL; /* filled in by postmaster_forkexec */#endif snprintf(typebuf, sizeof(typebuf), \"-x%d\", type); av[ac++] = typebuf; av[ac] = NULL; Assert(ac &lt; lengthof(av));#ifdef EXEC_BACKEND pid = postmaster_forkexec(ac, av);#else /* !EXEC_BACKEND */ pid = fork_process(); if (pid == 0) /* child */ &#123; InitPostmasterChild(); /* Close the postmaster's sockets */ ClosePostmasterPorts(false); /* Release postmaster's working memory context */ MemoryContextSwitchTo(TopMemoryContext); MemoryContextDelete(PostmasterContext); PostmasterContext = NULL; AuxiliaryProcessMain(ac, av);//实际的创建子进程 ExitPostmaster(0); &#125;#endif /* EXEC_BACKEND */ if (pid &lt; 0) &#123; /* in parent, fork failed */ int save_errno = errno; errno = save_errno; switch (type) &#123; case StartupProcess: ereport(LOG, (errmsg(\"could not fork startup process: %m\"))); break; case BgWriterProcess: ereport(LOG, (errmsg(\"could not fork background writer process: %m\"))); break; case CheckpointerProcess: ereport(LOG, (errmsg(\"could not fork checkpointer process: %m\"))); break; case WalWriterProcess: ereport(LOG, (errmsg(\"could not fork WAL writer process: %m\"))); break; case WalReceiverProcess: ereport(LOG, (errmsg(\"could not fork WAL receiver process: %m\"))); break; default: ereport(LOG, (errmsg(\"could not fork process: %m\"))); break; &#125; /* * fork failure is fatal during startup, but there's no need to choke * immediately if starting other child types fails. */ if (type == StartupProcess) ExitPostmaster(1); return 0; &#125; /* * in parent, successful fork */ return pid;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291/* * AuxiliaryProcessMain * * The main entry point for auxiliary processes, such as the bgwriter, * walwriter, walreceiver, bootstrapper and the shared memory checker code. * * This code is here just because of historical reasons. */voidAuxiliaryProcessMain(int argc, char *argv[])&#123; char *progname = argv[0]; int flag; char *userDoption = NULL; /* * Initialize process environment (already done if under postmaster, but * not if standalone). */ if (!IsUnderPostmaster) InitStandaloneProcess(argv[0]); /* * process command arguments */ /* Set defaults, to be overridden by explicit options below */ if (!IsUnderPostmaster) InitializeGUCOptions(); /* Ignore the initial --boot argument, if present */ if (argc &gt; 1 &amp;&amp; strcmp(argv[1], \"--boot\") == 0) &#123; argv++; argc--; &#125; /* If no -x argument, we are a CheckerProcess */ MyAuxProcType = CheckerProcess; while ((flag = getopt(argc, argv, \"B:c:d:D:Fkr:x:X:-:\")) != -1) &#123; switch (flag) &#123; case 'B': SetConfigOption(\"shared_buffers\", optarg, PGC_POSTMASTER, PGC_S_ARGV); break; case 'D': userDoption = pstrdup(optarg); break; case 'd': &#123; /* Turn on debugging for the bootstrap process. */ char *debugstr; debugstr = psprintf(\"debug%s\", optarg); SetConfigOption(\"log_min_messages\", debugstr, PGC_POSTMASTER, PGC_S_ARGV); SetConfigOption(\"client_min_messages\", debugstr, PGC_POSTMASTER, PGC_S_ARGV); pfree(debugstr); &#125; break; case 'F': SetConfigOption(\"fsync\", \"false\", PGC_POSTMASTER, PGC_S_ARGV); break; case 'k': bootstrap_data_checksum_version = PG_DATA_CHECKSUM_VERSION; break; case 'r': strlcpy(OutputFileName, optarg, MAXPGPATH); break; case 'x': MyAuxProcType = atoi(optarg); break; case 'X': &#123; int WalSegSz = strtoul(optarg, NULL, 0); if (!IsValidWalSegSize(WalSegSz)) ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg(\"-X requires a power of two value between 1 MB and 1 GB\"))); SetConfigOption(\"wal_segment_size\", optarg, PGC_INTERNAL, PGC_S_OVERRIDE); &#125; break; case 'c': case '-': &#123; char *name, *value; ParseLongOption(optarg, &amp;name, &amp;value); if (!value) &#123; if (flag == '-') ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg(\"--%s requires a value\", optarg))); else ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg(\"-c %s requires a value\", optarg))); &#125; SetConfigOption(name, value, PGC_POSTMASTER, PGC_S_ARGV); free(name); if (value) free(value); break; &#125; default: write_stderr(\"Try \\\"%s --help\\\" for more information.\\n\", progname); proc_exit(1); break; &#125; &#125; if (argc != optind) &#123; write_stderr(\"%s: invalid command-line arguments\\n\", progname); proc_exit(1); &#125; /* * Identify myself via ps */ if (IsUnderPostmaster) &#123; const char *statmsg; switch (MyAuxProcType) &#123; case StartupProcess: statmsg = pgstat_get_backend_desc(B_STARTUP); break; case BgWriterProcess: statmsg = pgstat_get_backend_desc(B_BG_WRITER); break; case CheckpointerProcess: statmsg = pgstat_get_backend_desc(B_CHECKPOINTER); break; case WalWriterProcess: statmsg = pgstat_get_backend_desc(B_WAL_WRITER); break; case WalReceiverProcess: statmsg = pgstat_get_backend_desc(B_WAL_RECEIVER); break; default: statmsg = \"??? process\"; break; &#125; init_ps_display(statmsg, \"\", \"\", \"\"); &#125; /* Acquire configuration parameters, unless inherited from postmaster */ if (!IsUnderPostmaster) &#123; if (!SelectConfigFiles(userDoption, progname)) proc_exit(1); &#125; /* * Validate we have been given a reasonable-looking DataDir and change * into it (if under postmaster, should be done already). */ if (!IsUnderPostmaster) &#123; checkDataDir(); ChangeToDataDir(); &#125; /* If standalone, create lockfile for data directory */ if (!IsUnderPostmaster) CreateDataDirLockFile(false); SetProcessingMode(BootstrapProcessing); IgnoreSystemIndexes = true; /* Initialize MaxBackends (if under postmaster, was done already) */ if (!IsUnderPostmaster) InitializeMaxBackends(); BaseInit(); /* * When we are an auxiliary process, we aren't going to do the full * InitPostgres pushups, but there are a couple of things that need to get * lit up even in an auxiliary process. */ if (IsUnderPostmaster) &#123; /* * Create a PGPROC so we can use LWLocks. In the EXEC_BACKEND case, * this was already done by SubPostmasterMain(). */#ifndef EXEC_BACKEND InitAuxiliaryProcess();#endif /* * Assign the ProcSignalSlot for an auxiliary process. Since it * doesn't have a BackendId, the slot is statically allocated based on * the auxiliary process type (MyAuxProcType). Backends use slots * indexed in the range from 1 to MaxBackends (inclusive), so we use * MaxBackends + AuxProcType + 1 as the index of the slot for an * auxiliary process. * * This will need rethinking if we ever want more than one of a * particular auxiliary process type. */ ProcSignalInit(MaxBackends + MyAuxProcType + 1); /* finish setting up bufmgr.c */ InitBufferPoolBackend(); /* * Auxiliary processes don't run transactions, but they may need a * resource owner anyway to manage buffer pins acquired outside * transactions (and, perhaps, other things in future). */ CreateAuxProcessResourceOwner(); /* Initialize backend status information */ pgstat_initialize(); pgstat_bestart(); /* register a before-shutdown callback for LWLock cleanup */ before_shmem_exit(ShutdownAuxiliaryProcess, 0); &#125; /* * XLOG operations */ SetProcessingMode(NormalProcessing); switch (MyAuxProcType) &#123; case CheckerProcess: /* don't set signals, they're useless here */ CheckerModeMain(); proc_exit(1); /* should never return */ case BootstrapProcess: /* * There was a brief instant during which mode was Normal; this is * okay. We need to be in bootstrap mode during BootStrapXLOG for * the sake of multixact initialization. */ SetProcessingMode(BootstrapProcessing); bootstrap_signals(); BootStrapXLOG(); BootstrapModeMain(); proc_exit(1); /* should never return */ case StartupProcess: /* don't set signals, startup process has its own agenda */ StartupProcessMain(); proc_exit(1); /* should never return */ case BgWriterProcess: /* don't set signals, bgwriter has its own agenda */ BackgroundWriterMain(); proc_exit(1); /* should never return */ case CheckpointerProcess: /* don't set signals, checkpointer has its own agenda */ CheckpointerMain(); proc_exit(1); /* should never return */ case WalWriterProcess: /* don't set signals, walwriter has its own agenda */ InitXLOGAccess(); WalWriterMain(); proc_exit(1); /* should never return */ case WalReceiverProcess: /* don't set signals, walreceiver has its own agenda */ WalReceiverMain(); proc_exit(1); /* should never return */ default: elog(PANIC, \"unrecognized process type: %d\", (int) MyAuxProcType); proc_exit(1); &#125;&#125; 3）创建服务进程进程 ​ 其中检测辅助进程是否存在，若不存在，则创建之，调用2）中的创建进程的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240/* * Main idle loop of postmaster * * NB: Needs to be called with signals blocked */static intServerLoop(void)&#123; fd_set readmask; int nSockets; time_t last_lockfile_recheck_time, last_touch_time; last_lockfile_recheck_time = last_touch_time = time(NULL); nSockets = initMasks(&amp;readmask); for (;;) &#123; fd_set rmask; int selres; time_t now; /* * Wait for a connection request to arrive. * * We block all signals except while sleeping. That makes it safe for * signal handlers, which again block all signals while executing, to * do nontrivial work. * * If we are in PM_WAIT_DEAD_END state, then we don't want to accept * any new connections, so we don't call select(), and just sleep. */ memcpy((char *) &amp;rmask, (char *) &amp;readmask, sizeof(fd_set)); if (pmState == PM_WAIT_DEAD_END) &#123; PG_SETMASK(&amp;UnBlockSig); pg_usleep(100000L); /* 100 msec seems reasonable */ selres = 0; PG_SETMASK(&amp;BlockSig); &#125; else &#123; /* must set timeout each time; some OSes change it! */ struct timeval timeout; /* Needs to run with blocked signals! */ DetermineSleepTime(&amp;timeout); PG_SETMASK(&amp;UnBlockSig); selres = select(nSockets, &amp;rmask, NULL, NULL, &amp;timeout); PG_SETMASK(&amp;BlockSig); &#125; /* Now check the select() result */ if (selres &lt; 0) &#123; if (errno != EINTR &amp;&amp; errno != EWOULDBLOCK) &#123; ereport(LOG, (errcode_for_socket_access(), errmsg(\"select() failed in postmaster: %m\"))); return STATUS_ERROR; &#125; &#125; /* * New connection pending on any of our sockets? If so, fork a child * process to deal with it. */ if (selres &gt; 0) &#123; int i; for (i = 0; i &lt; MAXLISTEN; i++) &#123; if (ListenSocket[i] == PGINVALID_SOCKET) break; if (FD_ISSET(ListenSocket[i], &amp;rmask)) &#123; Port *port; port = ConnCreate(ListenSocket[i]); if (port) &#123; BackendStartup(port); /* * We no longer need the open socket or port structure * in this process */ StreamClose(port-&gt;sock); ConnFree(port); &#125; &#125; &#125; &#125; /* If we have lost the log collector, try to start a new one */ if (SysLoggerPID == 0 &amp;&amp; Logging_collector) SysLoggerPID = SysLogger_Start(); /* * If no background writer process is running, and we are not in a * state that prevents it, start one. It doesn't matter if this * fails, we'll just try again later. Likewise for the checkpointer. */ if (pmState == PM_RUN || pmState == PM_RECOVERY || pmState == PM_HOT_STANDBY) &#123; if (CheckpointerPID == 0) CheckpointerPID = StartCheckpointer(); if (BgWriterPID == 0) BgWriterPID = StartBackgroundWriter(); &#125; /* * Likewise, if we have lost the walwriter process, try to start a new * one. But this is needed only in normal operation (else we cannot * be writing any new WAL). */ if (WalWriterPID == 0 &amp;&amp; pmState == PM_RUN) WalWriterPID = StartWalWriter(); /* * If we have lost the autovacuum launcher, try to start a new one. We * don't want autovacuum to run in binary upgrade mode because * autovacuum might update relfrozenxid for empty tables before the * physical files are put in place. */ if (!IsBinaryUpgrade &amp;&amp; AutoVacPID == 0 &amp;&amp; (AutoVacuumingActive() || start_autovac_launcher) &amp;&amp; pmState == PM_RUN) &#123; AutoVacPID = StartAutoVacLauncher(); if (AutoVacPID != 0) start_autovac_launcher = false; /* signal processed */ &#125; /* If we have lost the stats collector, try to start a new one */ if (PgStatPID == 0 &amp;&amp; (pmState == PM_RUN || pmState == PM_HOT_STANDBY)) PgStatPID = pgstat_start(); /* If we have lost the archiver, try to start a new one. */ if (PgArchPID == 0 &amp;&amp; PgArchStartupAllowed()) PgArchPID = pgarch_start(); /* If we need to signal the autovacuum launcher, do so now */ if (avlauncher_needs_signal) &#123; avlauncher_needs_signal = false; if (AutoVacPID != 0) kill(AutoVacPID, SIGUSR2); &#125; /* If we need to start a WAL receiver, try to do that now */ if (WalReceiverRequested) MaybeStartWalReceiver(); /* Get other worker processes running, if needed */ if (StartWorkerNeeded || HaveCrashedWorker) maybe_start_bgworkers();#ifdef HAVE_PTHREAD_IS_THREADED_NP /* * With assertions enabled, check regularly for appearance of * additional threads. All builds check at start and exit. */ Assert(pthread_is_threaded_np() == 0);#endif /* * Lastly, check to see if it's time to do some things that we don't * want to do every single time through the loop, because they're a * bit expensive. Note that there's up to a minute of slop in when * these tasks will be performed, since DetermineSleepTime() will let * us sleep at most that long; except for SIGKILL timeout which has * special-case logic there. */ now = time(NULL); /* * If we already sent SIGQUIT to children and they are slow to shut * down, it's time to send them SIGKILL. This doesn't happen * normally, but under certain conditions backends can get stuck while * shutting down. This is a last measure to get them unwedged. * * Note we also do this during recovery from a process crash. */ if ((Shutdown &gt;= ImmediateShutdown || (FatalError &amp;&amp; !SendStop)) &amp;&amp; AbortStartTime != 0 &amp;&amp; (now - AbortStartTime) &gt;= SIGKILL_CHILDREN_AFTER_SECS) &#123; /* We were gentle with them before. Not anymore */ TerminateChildren(SIGKILL); /* reset flag so we don't SIGKILL again */ AbortStartTime = 0; &#125; /* * Once a minute, verify that postmaster.pid hasn't been removed or * overwritten. If it has, we force a shutdown. This avoids having * postmasters and child processes hanging around after their database * is gone, and maybe causing problems if a new database cluster is * created in the same place. It also provides some protection * against a DBA foolishly removing postmaster.pid and manually * starting a new postmaster. Data corruption is likely to ensue from * that anyway, but we can minimize the damage by aborting ASAP. */ if (now - last_lockfile_recheck_time &gt;= 1 * SECS_PER_MINUTE) &#123; if (!RecheckDataDirLockFile()) &#123; ereport(LOG, (errmsg(\"performing immediate shutdown because data directory lock file is invalid\"))); kill(MyProcPid, SIGQUIT); &#125; last_lockfile_recheck_time = now; &#125; /* * Touch Unix socket and lock files every 58 minutes, to ensure that * they are not removed by overzealous /tmp-cleaning tasks. We assume * no one runs cleaners with cutoff times of less than an hour ... */ if (now - last_touch_time &gt;= 58 * SECS_PER_MINUTE) &#123; TouchSocketFiles(); TouchSocketLockFiles(); last_touch_time = now; &#125; &#125;&#125; 更新时间1） 2021-02-05 初步粗度代码并调试进程创建。遗留问题：很多系统调用太长时间不用已经遗忘；Fork的代码10年调试过，但也忘记","categories":[],"tags":[]},{"title":"Spring AOP","slug":"Spring-AOP","date":"2020-07-23T02:25:04.000Z","updated":"2020-07-25T11:41:41.177Z","comments":true,"path":"2020/07/23/Spring-AOP/","link":"","permalink":"http://yoursite.com/2020/07/23/Spring-AOP/","excerpt":"","text":"Spring AOP 需求如果自己是Spring IOC 的架构师，现在要在IOC容器的基础上添加AOP的支持，要解决什么问题？ 对程序员用户呈现的接口是什么? 户如何向Spring描述要增强的对象 用户如何描述要增强的行为 Spring IOC 容器如何处理要增强的对象 如何识别要增强的对象 在何时增强对象 增强对象运行时是如何实现的 技术选型参考比较Spring AOP与AspectJ Spring AOP and AspectJ对比Spirng AOP和AspectJ的特性：能力和目标、植入方式、内部结构和应用、连接点和简单性。 结论: Spring AOP完整的AOP解决方案，它只能用于Spring容器管理的beans。 AspectJ使用的是编译期和类加载时进行织入，Spring AOP利用的是运行时织入 Spring AOP的实现植入方式不同 JDK 实现 InnovationHandler接口 GCLIB继承要增强的对象 AspectJ在运行时不做任何事情，类和切面是直接编译的，其引入了自己的编译期，成为AspectJ Compiler JointPoints。 SpringAOP基于代理模式，因此需要目标类的子类(接口实现或类继承)，并应用响应的横切点关注点。这带来了局限性，即不能跨越”final“的类进行应用横切关注点，因为它们不能覆盖，否则导致运行时异常 在Spring AOP中，切面不适用于同一个类中调用的方法，原因是：同一个类中调用一个方法时，并没有调用Spring AOP提供的代理的方法。 简单。 Spring AOP 在运行期植入，无缝集成于IOC容器；AspectJ需要引入AJC编译器，重新打包所有库（除非我们切换到编译后或加载时织入） 性能。AspectJ经过测试大概8到35倍快于Spring AOP Spring AOP 基础API 一开始就看一些高阶的实现，如ProxyFactory等实在是看的云里雾里，从AspectJ简单实现开始看起，然后过渡到Spring AOP的ProxyFactory就舒服很多。建议参考如下的文章或代码 Spring AOP核心API 从简单讲起，逐步引入Spring AOP的核心实现 Spring 源码中的子项目 Spring AOP 单元测试org.springframework.aop.framework.ProxyFactoryTests 收获总结如下： 了解了GCLIB的Enhancer的实现，对比JKD 的InvokeHnadler的实现 Enhancer只能用于创建cglib动态代理 Spring中还有一个更上层点的类ProxyFactory，可以用于创建JDK动态代理或cglib动态代理 AnnotationAwareAspectJAutoProxyCreator、BeanNameAutoProxyCreator、DefaultAdvisorAutoProxyCreator等一些高级AOP实现工具类都是通过在其父类AbstractAutoProxyCreator中借助ProxyFactory实现AOP逻辑织入的 ProxyFactory类addAdvice()方法将传入的通知封装到DefaultPointcutAdvisor(DefaultPointcutAdvisor是PointcutAdvisor的标准实现)的一个实例中，并使用默认包含所有方法的切入点对其进行配置 Advisor 在AOP规范中有切面概念，在Spring中大概对应就是Advisor。Advisor有两个子接口：PointcutAdvisor和IntroductionAdvisor，其实真正使用比较多的是它的子类PointcutAdvisor，该接口关键就是如下两个方法： 1234public interface PointcutAdvisor &#123; Advice getAdvice(); Pointcut getPointcut();&#125; PointcutAdvisor从接口定义大概就可以看出，其就是对Advice和Pointcut的封装，Advice代表的是横切面需要织入的代码，而Pointcut定义了如何去切的问题 Spring实现预备知识 IOC容器初始化，即AbstractApplicationContext#refresh 理解finishBeanFactoryInitialization和finishBeanFactoryInitialization所实现的接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. //1.扫描Bean定义 class--&gt; bean //2.执行程序员定义的BeanFactoryPostProcessor /** * ConfigurationClassPostProcessor实现了BeanDefinitionRegistry`PostProcessor接口，也就拥有了在Spring容器启动时，往容器中注册BeanDefinition的能力。 * ConfigurationClassPostProcessor 扫描@Configutation、@Component、@Resourece、@ImportResource、@CompentScan注解的类， * 并调用递归BeanefinitionClassPath从其所在的class下不断扫描注解的类包括@bean注解，并将其加加入bdMap中 * */ invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. // 从方法名就可以知道，典型的模板方法(钩子方法)， // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前） onRefresh(); // Check for listener beans and register them. // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过 registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. // 重点，重点，重点 // 初始化所有的 singleton beans //（lazy-init 的除外） finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. // 最后，广播事件，ApplicationContext 初始化完成 finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125; &#125; 开启Spring AOP 开启Spring AOP ，使用@EnableAspectJAutoProxy 注入AnnotationAwareAspectJAutoProxyCreator ，实现了BeanPostProcessor，继承关系如下： @EnableAspectJAutoProxy注解在invokeBeanFactoryPostProcessors函数中的ConfigurationClassPostProcessor被扫描到，通过import注册到系统中 解析注解@Aspectj 思路：在IOC容器中扫描有@AspectJ的bd，解析生成Advisor 参考文章Spring Core Middleware 源码分析二：Spring AOP 之 @AspectJ 流程图绘制的很清晰 简单描述一下： 1234567891011AbstractApplicationContext#finishBeanFactoryInitialization |_AbstractApplicationContext#finishBeanFactoryInitialization |_beanFactory#getBean ... |_beanFactory#getBean |_AbstractAutowireCapableBeanFactory#createBean |_AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation |_AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInstantiation |_AnnotationAwareAspectJAutoProxyCreator[AbstractAutoProxyCreator]#postProcessBeforeInstantiation ... |_BeanFactoryAspectJAdvisorsBuilder#buildAspectJAdvisors 扫描IOC中有@AspectJ注解的Bean，解析为Advisor，并缓存到系统中 生成bean的代理对象 12345678910111213141516171819AbstractAutowireCapableBeanFactory#createBean |_ AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation |_applyBeanPostProcessorsBeforeInstantiation(其中包括查找@Aspectj注解的切面类) |_applyBeanPostProcessorsAfterInitialization |_AbstractAutowireCapableBeanFactory#doCreateBean |_ populateBean |_ postProcessAfterInstantiation |_initializeBean |_ invokeAwareMethods |_ BeanNameAware |_ BeanClassLoaderAware |_ BeanFactoryAware |_ applyBeanPostProcessorsBeforeInitialization |_ invokeInitMethods |_ invokeCustomInitMethod |_ applyBeanPostProcessorsAfterInitialization |_AbstractAutoProxyCreator#postProcessAfterInitialization |_ AbstractAutoProxyCreator#wrapIfNecessary |_createProxy 代理对象执行名词解释 CGLib(code generation lib) 基于ASM 修订历史 2020-07-25 初步完成 开启SpringAOP、注解解析@AspectJ、生成bean的代理对象的章节","categories":[],"tags":[{"name":"Spring AOP","slug":"Spring-AOP","permalink":"http://yoursite.com/tags/Spring-AOP/"}]}],"categories":[],"tags":[{"name":"Spring AOP","slug":"Spring-AOP","permalink":"http://yoursite.com/tags/Spring-AOP/"}]}